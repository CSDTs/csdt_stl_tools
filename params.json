{"name":"Stl tools","tagline":"Python code to produce STL geometry files from plain text, LaTeX code, and 2D numerical arrays (matrices) ","body":"![Alt text](http://i.imgur.com/CdZzhBp.png \"Screenshot\")\r\n\r\nstl_tools\r\n=======================\r\nPython code to generate STL geometry files from plain text, LaTeX code, and 2D numpy arrays (matrices).\r\n\r\nThis allows for rapid 3D printing of text, rendered equations, or simple digital images.\r\nUse them for product prototyping, art, cookie cutters, ice cube trays, chocolate molds, (see [this](http://www.makerbot.com/tutorials/making-chocolate-molds/) \r\nto learn how to make a printed object food-safe) or whatever else you can think of.\r\n\r\nSome modification may be needed to the STL or printer settings to get certain shapes to print cleanly (ie. thicker base, \r\nsupport structures, etc).\r\n\r\nBesides printing, these can also be merged into other 3D meshes for many other \r\npossible uses, using programs such as Blender.\r\n\r\nAlso included is a function that can convert raw LaTeX expressions to high\r\nquality .png images, which allows for simple inclusion of LaTeX equations into \r\nnon-LaTeX document editors.\r\n\r\n A command-line script for converting images to STL (no text yet) is included in the installation for those who do not\r\nwant to write Python code directly.\r\n\r\n## Requirements:\r\n- [Python](http://python.org/) 2.7 or higher (Python 3.x not yet tested, but would probably work)\r\n- [Numpy](http://www.numpy.org/) 1.7 or higher (for array manipulation)\r\n- [Scipy](http://www.scipy.org/) 0.12 or higher (for image reading and filtering functions)\r\n- [Matplotlib](http://matplotlib.org/) 1.2.1 or higher (for rendering text and LaTeX to image data)\r\n\r\n## Installation:\r\nRun `python setup.py build install` to install. \r\n\r\nThis will check for the 3rd party\r\ndependencies above and install the library. \r\n\r\nThis will also install the\r\ncommand line script `image2stl` into the `Python/Scripts` directory.\r\n\r\n## Quickstart Examples:\r\n\r\nRun the file `examples.py` to produce a few sample STL files from images included in `examples/example_data`.\r\n\r\nThe first example converts the commonly-used [Lena test image](http://en.wikipedia.org/wiki/Lenna) to an STL file\r\n\r\n```python\r\nfrom stl_tools import numpy2stl\r\n\r\nfrom scipy.misc import lena, imresize\r\nfrom scipy.ndimage import gaussian_filter\r\n\r\nA = imresize(lena(), (256,256)) # load Lena image, shrink in half\r\nA = gaussian_filter(A, 1) # smoothing\r\n\r\nnumpy2stl(A, \"examples/Lena.stl\", scale=0.1)\r\n```\r\n\r\nSource image vs. output geometry:\r\n![Alt text](http://i.imgur.com/CdZzhBp.png \"Screenshot\")\r\n\r\n[Click to view STL (view as wireframe)](examples/Lena.stl)\r\n\r\n---\r\n\r\nThe next three examples convert logos to STL, using color information to achieve appropriate 3D layering\r\n\r\nPython code:\r\n\r\n```python\r\nfrom scipy.misc import imread\r\n\r\nA = imread(\"examples/example_data/NASA.png\")\r\nA = A[:,:,2] + 1.0*A[:,:,0] # Compose elements from RGBA channels to give depth \r\nA = gaussian_filter(A, 1) # smoothing\r\n\r\nnumpy2stl(A, \"examples/NASA.stl\", scale=0.05, mask_val = 5.)\r\n```\r\nEquivalent command-line syntax:\r\n```bash\r\n> image2stl NASA.png -scale 0.05 -mask_val 5. -RGBA_weights 1. 0. 1. 0. -gaussian_filter 1\r\n```\r\n\r\n![Alt text](http://i.imgur.com/LFvw5Yn.png \"Screenshot\")\r\n[Click to view STL (view as wireframe)](examples/NASA.stl)\r\n\r\n---\r\n\r\nPython code:\r\n\r\n```python\r\nA = imread(\"examples/example_data/openmdao.png\")\r\nA =  A[:,:,0] + 1.*A[:,:,3] # Compose elements from RGBA  channels to give depth \r\nA = gaussian_filter(A, 2) # smoothing\r\n\r\nnumpy2stl(A, \"examples/OpenMDAO-logo.stl\", scale=0.05, mask_val = 1.)\r\n```\r\n\r\nEquivalent command-line syntax:\r\n```bash\r\n> image2stl openmdao.png -scale 0.05 -mask_val 1. -RGBA_weights 1. 0. 0. 1. -gaussian_filter 2\r\n```\r\n\r\nSource image vs. output geometry:\r\n![Alt text](http://i.imgur.com/70wFtCR.png \"Screenshot\")\r\n\r\n[Click to view STL (view as wireframe)](examples/OpenMDAO-logo.stl)\r\n\r\n---\r\n\r\nFinally, this example renders a LaTeX expression into a png image, then converts this image to an STL.\r\n\r\nNote that LaTeX expressions which coincidentally contain special ASCII markers (such as `\\n` and `\\r`) \r\nhave to be escaped with an additional slash in those positions in order to be properly rendered, unless these\r\nmarkers are intended. \r\n\r\nPython code:\r\n\r\n```python\r\nfrom stl_tools import numpy2stl, text2png, text2array\r\n\r\ntext = (\"$\\oint_{\\Gamma} (A\\, dx + B\\, dy) = \\iint_{U} \\left(\\\\frac{\\partial \"\r\n        \"B}{\\partial x} - \\\\frac{\\partial A}{\\partial y}\\\\right)\\ dxdy$ \\n\\n \"\r\n        \"$\\\\frac{\\partial \\\\rho}{\\partial t} + \\\\frac{\\partial}{\\partial x_j}\"\r\n        \"\\left[ \\\\rho u_j \\\\right] = 0$\")\r\ntext2png(text, \"examples/Greens-Theorem_Navier-Stokes\", fontsize=50) #save png \r\n\r\nA = imread(\"examples/Greens-Theorem_Navier-Stokes.png\") # read from rendered png\r\nA = A.mean(axis=2) #grayscale projection\r\nA = gaussian_filter(A.max() - A, 1.) \r\n\r\nnumpy2stl(A, \"examples/Greens-Theorem_Navier-Stokes.stl\", scale=0.2, \r\n                                                         mask_val = 5.)\r\n```\r\nSource image vs. output geometry:\r\n![Alt text](examples/Greens-Theorem_Navier-Stokes.png \"Screenshot\")\r\n![Alt text](http://i.imgur.com/TgHlFGK.png \"Screenshot\")\r\n\r\n[Click to view STL (view as wireframe)](examples/Greens-Theorem_Navier-Stokes.stl)\r\n\r\n\r\n## Library usage:\r\nThere are 3 principal functions (no classes) to import and use from stl_tools:\r\n\r\n### `stl_tools.numpy2stl`\r\n    numpy2stl(A, fn, scale=0.1, mask_val = -np.inf, ascii=False, calc_normals=False)\r\n    Reads a numpy array, and outputs an STL file\r\n\r\n    Inputs:\r\n     A (ndarray) -  an 'm' by 'n' 2D numpy array\r\n     fn (string) -  filename to use for STL file\r\n\r\n    Optional input:\r\n     scale (float)  -  scales the height (surface) of the \r\n                       resulting STL mesh. Tune to match needs\r\n\r\n     mask_val (float) - any element of the inputted array that is less\r\n                        than this value will not be included in the mesh.\r\n                        default renders all vertices (x > -inf for all float x)\r\n\r\n     ascii (bool)  -  sets the STL format to ascii or binary (default)\r\n\r\n     calc_normals (bool) - sets whether surface normals are calculated or not\r\n\r\n     max_width, max_depth, max_height (floats) - maximum size of the stl\r\n                                                object (in mm). Match this to\r\n                                                the dimensions of a 3D printer platform \r\n\r\n    Returns: (None)\r\n\r\n`numpy2stl()` is the main function of this repository. \r\n\r\nIt takes a 2D numpy array and output filename\r\nas input, and writes an STL file. \r\n\r\nEach element of the array is tesselated to its neighbors to produce 2 triangular faces for\r\nevery 4 contiguous elements. The depth axis of any vertex is taken to be the value of the array corresponding to that point.\r\n\r\nThe `scale` argument scales the height of the resulting geometry. It's a similair effect to extruding or shrinking.\r\n\r\nThe `mask_val` argument allows you to set a threshold value for elements in the input array for exclusion in the STL file.\r\nArray elements which are less than this value will not be included as vertices.\r\nIt takes a bit of trial-and-error to get these just right. Plotting the intermediate arrays\r\nwith a colorbar (to show scaling) helps in finding decent values.\r\n\r\nThe `max_width`, `max_height`, and `max_depth` values are measurements (in mm) used to scale the final output to \r\nthe largest size that can fit onto your 3D printer platform. Default values are for the MakerBot Replicator.\r\n\r\n\r\n### `stl_tools.text2png`\r\n    text2png(text, fn = None)\r\n    Renders inputted text to a png image using matplotlib.\r\n\r\n    Inputs:\r\n     text (string) -  text to render\r\n\r\n    Optional input:\r\n     fn (string)  -  filename of png to be outputted.\r\n                     defaults to the entered text\r\n\r\n    Returns: (None)\r\n\r\n`text2png()` was written as an intermediate helper function to render text to pngs, to then be imported, filtered, and meshed.\r\nHowever, it may be useful in it's own right. For example, it can be used alone to render LaTeX expressions into images, to be imported into WYSIWYG document editors like MS Word or LibreOffice Writer. \r\n\r\n### `stl_tools.text2array`\r\n    text2array(text)\r\n    Renders inputted text, and returns array representation.\r\n\r\n    Inputs:\r\n     text (string) -  text to render\r\n\r\n    Returns: A (ndarray) - 2D numpy array of rendered text\r\n    \r\n\r\n`text2array()` renders inputted text using `text2png()`, but imports the resulting png as an ndarray and deletes the intermediate file.\r\nThere may be a direct way to render the matplotlib figure as an array without using an intermediate file, but I could not seem to find a simple\r\nway in the matplotlib docs.\r\n\r\n## Command-line scripts\r\n\r\n### `image2stl`\r\n\r\n`image2stl` is a command-line script that is installed via entry points when `setup.py` is run.\r\nThis provides a simple command-line interface to the functions of this library, with the same\r\narguments. See the examples above for usage.\r\n\r\n## Tips:\r\n\r\n- Consider scaling down a digital image before generating an STL from its pixels.\r\nFor images of standard sizes for modern cameras, the resulting STL filesize can be pretty large.\r\n\r\n- Just like was shown in the examples, applying a simple filtering function to smooth\r\nsharp edges results in an STL geometry that is likely to be more easily printable. Fine tuning in a \r\nprogram like Photoshop or Gimp can also help prevent spikes/jagged edges in the geometry. Contrast\r\nequalization or other types of filters may also be helpful (haven't tried yet).\r\n\r\n- To make a proper mold, scale up the edges of the source image to match the maximum pixel value of the image (or higher), to form a lip. \r\nFor example:\r\n```python\r\nm, n = A.shape\r\nborder_val = 1.1 * A.max()\r\nA[0::m-1, :] = border_val # make top and bottom lip\r\nA[:, 0::n-1] = border_val # make left and right lip\r\n```\r\nIn practice, the border may need to be thicker than 1 pixel.\r\n\r\n## Todo/future features:\r\n\r\n- Photos of actual printed models. \r\n\r\n- I'm looking into writing a utility function to refine STL meshes by removing redundant vertices (so that wide flat spaces aren't packed with dense tessellations)\r\n\r\n- It's possible to apply various warping functions to the resulting \r\nmeshes. So you could load an image, warp the result into a cylinder, and have a \r\ntextured column (or something like that).\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}